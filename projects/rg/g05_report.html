<link rel='stylesheet' href='style.css' type='text/css'>







<html> <title> Report </title> <body><a name='top'>Contents</a></br><div id='contents'> <ol><li><a href='#Introduction'> Introduction</a></li><li><a href='#PresentandOriginalDesign'> Present and Original Design</a></li><li><a href='#InterestingPartsofourDesign'> Interesting Parts of our Design</a></li><li><a href='#Analysisofplots'> Analysis of plots</a></li><li><a href='#CodeProfilingReport'> Code Profiling Report</a></li><li><a href='#Otherdifferencesinreleaseanddebugmodes'> Other differences in release and debug modes</a></li><li><a href='#CallGraphs'> Call Graphs </a></li></ol> <ol> 






</ol><div class='section'> <a name='Introduction'> Introduction </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
This report explains the rube goldberg machine [<a href='#wiki'>wiki</a>] designed by us, its difference from the original design and the interesting parts in our design. We also analyse our code using various techniques. 


</ol><div class='section'> <a name='PresentandOriginalDesign'> Present and Original Design </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
Following are the images of the present design(left) and the original design(right) respectively :
</br>
</br>
<img style='width:430.0;height:301.0px' src='present_design.png'> </img> 
<img style='width:430.0;height:301.0px' src='rubeGoldberg.png'> </img> 
</br>
There are some minor additions to our original design to make our simulation work better. There are just three of them which are listed below:
<ol>
<li> We added a vertical wall to support the lever(in the top left corner of the smulation) that pushes the ball.
</br>
<img style='width:301.0;height:215.0px' src='change1.png'> </img> 
<img style='width:301.0;height:215.0px' src='original1.png'> </img> 
<li> In our original design, a ball falls on the wedge(in the bottom left corner) that pushes a block placed on it which takes a projectile path and finally hits a set of multiple levers(on the rightmost part of the simulation). But a part of that motion of the block would not be visible as it would go above the visible area of the simulation. So we included a platform with a ball on it in the topmost part of the simulation. Now the projectile motion of that block becomes small and it hits the ball on the platform which takes forward the rest of the simulation. The image below shows the platform with the ball in the present design which was not present in the original design.
</br>
<img style='width:688.0;height:172.0px' src='change2.png'> </img> 
<li> This one is a very minor change in the rod connected to the pulley which you can figure out by the images of the present design(to the left) and the original design(to the right) shown below:
</br>
<img style='width:301.0;height:215.0px' src='change3.png'> </img> 
<img style='width:301.0;height:215.0px' src='original3.png'> </img> 
</br>
</ol> 


</ol><div class='section'> <a name='InterestingPartsofourDesign'> Interesting Parts of our Design </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
We would like to point out some parts of our simulation design that make it interesting.[<a href='#hcv'>hcv</a>] [<a href='#hrw'>hrw</a>]
<ol>
<li> There is a revolving platform on which a ball comes from its upper left side and it releases it towards its bottom right side.
</br>
<img style='width:215.0;height:172.0px' src='s1.png'> </img> 
<img style='width:215.0;height:172.0px' src='s2.png'> </img> 
<img style='width:215.0;height:172.0px' src='s3.png'> </img> 
<img style='width:215.0;height:172.0px' src='s4.png'> </img> 
</br>
<li> We think that this is the most interesting part of our simulation. There are two balls kept nearby each other on a horizontal surface and there is a vertical lever to the right. When the lever hits one of the balls, that ball(which is towards the right side) gets into motion and hits the other ball which goes forward and creates path for it to go forward. The images below explain the scenario:
</br>
<img style='width:215.0;height:172.0px' src='m1.png'> </img> 
<img style='width:215.0;height:172.0px' src='m2.png'> </img> 
<img style='width:215.0;height:172.0px' src='m3.png'> </img> 
<img style='width:215.0;height:172.0px' src='m4.png'> </img> 
</br>
<li> This is also an interesting part of our design. The ball(which is below) hits the wedge at a perfectly appropriate time which lifts the other part of wedge and creates a straight horizontal path for another ball(which is above).
</br>
<img style='width:215.0;height:172.0px' src='m7.png'> </img> 
<img style='width:215.0;height:172.0px' src='m8.png'> </img> 
<img style='width:215.0;height:172.0px' src='m9.png'> </img> 
<img style='width:215.0;height:172.0px' src='m10.png'> </img> 
</br>
<li> Our Rube Goldberg Machine ends by creating a smiley. This, we think, is another interesting aspect of our simulation.
</br>
<img style='width:344.0;height:258.0px' src='last.png'> </img> 
</br>
</ol> 


</ol><div class='section'> <a name='Analysisofplots'> Analysis of plots </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol>  
[<a href='#matplotlib'>matplotlib</a>] 
<div class='subsection'><li>Analysis of plot01(image below) : [Average (StepTime and LoopTime over reruns) vs number of iterations] </div> 
<ol>
<li> The stepTime and looptime are very close to each other. This is meaningful because the only major process that is happening inside the loop is Step function and apart from the step function, only a few addition, subtraction and reading is happening.
</ol> 

<img style='width:430.0' src='../plots/plot01.png'> </img> 
<img style='width:430.0' src='../plots/plot02.png'> </img> 

<div class='subsection'><li>Analysis of plot02(image above) : [Average (StepTime, CollisionTime, Velocity Time, Position update time over reruns) vs number of iterations] </div> 
<ol>
<li> In this case, an important thing to notice is that the collision time, velocity time and position update time add upto the step time. This proves that major things which happens inside the step function are collision handling, velocity update handling and position update handling.
<li> The ratio of the time taken by collision handling, velocity update handling, and position update handling is approximately same for different values of iteration number. Which is to say that, if more collisions are happening, then there is a greater need to update velocities and positions, which makes sense.
</ol> 

<div class='subsection'><li>Analysis of plot03(image below) : [Average of step time and looptime over iteration values vs rerun number] </div> 
<ol>
<li> The averages of looptime and steptime are same because of reasons mentioned earlier.
<li> The avg looptime over iteration values changes slightly for different rerun index. The important thing to notice that it is not constant. And the most likely reason for this is the other processes that runs in CPU during the execution of this program. So say when the nth iteration is running, the load on CPU might increase because of which the avg of step time over iteration values might increase for that particular rerun number. This justifies rerunning the program many times.
</ol> 

<img style='width:430.0' src='../plots/plot03.png'> </img> 
<img style='width:430.0' src='../plots/plot04.png'> </img> 

<div class='subsection'><li>Analysis of plot04(image above) : [Average of (step time, collision time, position update time, velocity update time over iteration values) vs the rerun number] </div> 
<ol>
<li> The analysis is very similar to the previous case. Again here the point that the sum of position update time, velocity update time, and collision update time is almost equal to step time and that the ratios are similar.
</ol> 

<div class='subsection'><li>Analysis of plot05(image below) : [Average of iteration values over reruns (with error bars) vs the iteration values] </div> 
<ol>
<li> The new feature is the error bars over plot1. The error decreases as the iteration values increases. On closely observing the step times from the actual data files, many a times the step times initially are very high and many times they are pretty low. This is perhaps because of the way in which the OS allocates CPU to the program. If the CPU is busy then the program gets less CPU initially and it increases into the program. However if the CPU is free then the program quickly gets sufficient CPU power. However when we consider higher iteration values, then the initial disturbance gets averaged out due to which the error is not so visible. 
</ol> 

<img style='width:430.0' src='../plots/plot05.png'> </img> 
<img style='width:430.0' src='../plots/plot06.png'> </img> 

<div class='subsection'><li>Analysis of plot06(image above) : [frequency of a particular step time vs the step time for iteration value 29] </div> 
<ol>
<li> The step time for different reruns are almost in a close range of 0.045ms to 0.050 ms. Approximately 70% of values are in this range. However in some exceptional cases, the step time came out to be upto 0.1 ms where the CPU load might have increased.
</ol> 

</ol><div class='section'> <a name='CodeProfilingReport'> Code Profiling Report </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
We profiled the code using gprof for 1L iterations in both release-mode and debug-mode.
</br>
First, let us analyze the report of debug-mode. 
</br>
<img style='width:774.0' src='debug_1L.png'> </img> 
<ol>
<li> First of all, we observe that simple functions like operator-, operator *, b2Vec2 (function for creating a new vector) are taking the maximum percentage of time. This shows that Box2D is a very computationally heavy process which relies on a lot of computation. In 1L steps , the b2Vec2 constructor is called a whopping 374743427 times, which means that it is called 3.7K times in each call of Step function.
<li> SolveVelocityConstraints of the b2RevoluteJoint class takes up a lot of time, perhaps because implementing joints are computationally expensive and required continued operations to find out their position. Morover our simulation uses revoluteJoints in many places
<li> Functions like solve of b2World class (which finds islands, integrates and solves constraints and  solves position constraints) , solveVelocityConstraints of b2ContactSolver(which solves the velocity constraints, the tangential forces on body, friction etc),  solveTOI of b2World class (which finds Time of Impact contacts and solve them) also takes up a lot of time. 	
<li> Again operations like finding max, finding min, taking the cross product or taking dot products of vectors takes up quite a lot of time despite being small functions sheerly because of the large number of times it is being called. 
</ol> 
Now let us consider the report of release-mode and consider the differences and similarities. Note that in the release-mode we have compiled Box2d in release-mode and also applied O3 optimizations to the code which lies in src folder. So we expect the gcc compiler to make many modifications to the code, making code inline(where possible), replacing recursive functions with a loop (where possible easily), moving variables from the stack to the register, etc. So lets analyze the release-profile clearly.
</br>
<img style='width:860.0' src='release_1L.png'> </img> 
<ol>
<li> The first thing we notice is that most of the functions which consumed a lot of time in debug-mode are absent in the release-mode profiling. So operator-, operator*, b2Vec2, b2Max have most likely been made inline by the compiler.
<li> The level of inlining is clear from the fact that 186 functions were detected by gprof in the debug-mode, while only 53 functions were detected by gprof in the release-mode.
<li> The percentage of time taken by SolveVelocityConstraints of b2ContactSolver is here the most time consuming function and it is taking 20% time in release-mode ; It was taki/ng just 5% time in debug-mode. This is most probably because when functions are made inline, then the time taken taken by those functions earlier are now counted in the function from where these functions were being called. The same reasoning perhaps applies for all the functions which are now new in the list of functions which are consuming high percentages of time taken by the program. Such things happens for many functions.
<li> It is notable that the Step function in the release-mode is not present at all in the debug-mode. On seeing the code for step function, we find out that step function calls many functions and does nothing else. Due to which its presence in debug-version was negligible; However it appears in the release-mode because of inlining of the functions which step function calls.
</ol>  

</ol><div class='section'> <a name='Otherdifferencesinreleaseanddebugmodes'> Other differences in release and debug modes </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
There is a marked difference in the time taken by code in the release and debug mode. The time taken by the code in the debug-mode is 18.29s, while the time taken in release-mode is just 1.942s. (These are values for 100K steps). This indicates that the code written by us are really inefficient as compared to what the compiler gives us.
</br>
The size of the executable in debug-mode is 1.4M, while in release-mode it is just 690K. 


</ol><div class='section'> <a name='CallGraphs'> Call Graphs  </a><div class='top'> <a href='#top'>Back to top</a></div> </div><ol> 
[<a href='#Gprof2Dot'>Gprof2Dot</a>]
The callgraphs for debug and release mode respectively :
</br>
<img style='width:860.0;height:129.0px' src='debug.png'> </img> 
</br>
</br>
<img style='width:860.0;height:43.0px' src='release.png'> </img> 
</br>
The call graphs represent the callee-caller relations. It shows all the functions that called a particular function 
and also all the functions that are called by it.

For release mode, we can see that there are no arcs coming out of
any functions which implies that all the callee functions are made
inline to the caller functions , where as there are a large number
of function calls which are present in callgraphs for debug mode.




 </ol></ol><div class='section'>References </div><ul><li><a name='wiki'></a> Wikipedia Page for Rube Goldberg <a href='http://en.wikipedia.org/wiki/Rube_Goldberg'>Link</a><li><a name='matplotlib'></a> Matplot lib for generation of plots <a href='http://matplotlib.org/'>Link</a><li><a name='Gprof2Dot'></a> Used for creation of call graphs <a href='https://code.google.com/p/jrfonseca/wiki/Gprof2Dot'>Link</a><li><a name='hcv'></a>Concepts of {Physics},{P}art1 by H.C.Verma<li><a name='hrw'></a>fundamentals of physics, 9th Ed. by Halliday,{R}esnick,{W}alker</body></html> 
